#include <assert.h>
#include <math.h>
#include "density.h"

    // data from Figure 6 of Curcio and Allen
    // *_x is eccentricity in mm
    // *_y is RGC density in #x1000 per mm^2
double nasal_x[DENSITY_DATA_LEN] = {
  0.00000000, 0.05274725, 0.10549451, 0.15824176, 0.21098901, 0.30769231,
  0.40439560, 0.50989011, 0.61538462, 0.71208791, 0.80879121, 0.91428571,
  1.01098901, 1.52087912, 2.02197802, 2.52307692, 3.03296703, 5.07317073,
  6.04878049, 7.07317073, 8.09756098, 9.12195122,10.09756098,11.12195122,
 12.09756098,13.17073171,14.14634146,15.12195122,16.19512195,17.12195122,
 18.19512195,19.17073171,20.14634146,21.17073171,21.17073171 };
double nasal_y[DENSITY_DATA_LEN] = {
  0.1411290, 0.8467742, 1.2701613, 2.6814516, 4.6572581,13.5483871,
 19.4758065,24.4153226,26.1088710,27.8024194,29.4959677,31.1895161,
 31.6129032,27.5201613,17.2177419,10.0201613, 6.6330645, 3.2905983,
  3.0769231, 2.8846154, 2.5641026, 2.0512821, 1.6239316, 1.3675214,
  1.2393162, 1.1324786, 1.0470085, 0.9401709, 0.8547009, 0.7478632,
  0.6410256, 0.5555556, 0.4059829, 0.3205128, 0.3205128};

double temporal_x[DENSITY_DATA_LEN] = {
  0.07032967, 0.12307692, 0.16703297, 0.20219780, 0.30769231, 0.40439560,
  0.50989011, 0.61538462, 0.70329670, 0.81758242, 0.91428571, 1.00219780,
  1.51208791, 2.03076923, 2.53186813, 3.03296703, 4.00879121, 4.04878049,
  5.07317073, 6.04878049, 7.07317073, 8.14634146, 9.07317073,10.09756098,
 11.12195122,12.14634146,13.12195122,14.14634146,15.17073171,16.14634146,
 16.14634146,16.14634146,16.14634146,16.14634146,16.14634146};
double temporal_y[DENSITY_DATA_LEN] = {
  0.1411290, 0.7056452, 1.8346774, 3.9516129,11.1491935,16.7943548,
 21.3104839,22.5806452,24.1330645,25.6854839,26.9556452,26.9556452,
 22.8629032,16.3709677,11.5725806, 8.3266129, 3.9516129, 3.9316239,
  2.3504274, 1.6666667, 1.1111111, 0.8119658, 0.6410256, 0.5128205,
  0.4273504, 0.3205128, 0.2777778, 0.2564103, 0.2136752, 0.1923077, 
  0.1923077, 0.1923077, 0.1923077, 0.1923077, 0.1923077};

double superior_x[DENSITY_DATA_LEN] = {
  0.008791209, 0.052747253, 0.105494505, 0.149450549, 0.210989011,
  0.316483516, 0.413186813, 0.509890110, 0.606593407, 0.712087912,
  0.808791209, 0.914285714, 1.019780220, 1.520879121, 2.021978022,
  2.531868132, 3.032967033, 4.000000000, 4.048780488, 4.975609756,
  6.000000000, 7.024390244, 8.048780488, 9.073170732,10.048780488,
 11.073170732,12.097560976,13.073170732,14.097560976,15.073170732,
 16.097560976,17.073170732,18.146341463,19.170731707,20.146341463};
double superior_y[DENSITY_DATA_LEN] = {
 -0.2845528,-0.1422764,-0.1422764, 0.2845528, 1.4227642, 9.2479675,
 18.2113821,24.4715447,26.8902439,27.7439024,27.8861789,27.8861789,
 27.0325203,18.4959350,11.3821138, 7.9674797, 5.6910569, 2.9878049,
  3.2513369, 2.1176471, 1.5614973, 1.3689840, 1.0695187, 0.8770053,
  0.6631016, 0.4705882, 0.4064171, 0.3636364, 0.3422460, 0.3208556,
  0.2780749, 0.2352941, 0.1711230, 0.1497326, 0.1283422};

double inferior_x[DENSITY_DATA_LEN] = {
  0.1142857, 0.1670330, 0.2109890, 0.3076923, 0.4043956, 0.5010989,
  1.0109890, 1.5120879, 2.0219780, 2.5230769, 3.0329670, 4.0000000,
  4.0487805, 4.9756098, 6.0487805, 6.9756098, 8.0975610, 9.0731707,
 10.0487805,11.0243902,12.0975610,13.0731707,14.0975610,15.1219512,
 16.0975610,17.1219512,18.0975610,19.1219512,
 19.1219512,19.1219512,19.1219512,19.1219512,19.1219512,19.1219512,19.1219512};
double inferior_y[DENSITY_DATA_LEN] = {
  1.13821138, 3.13008130, 6.26016260,14.36991870,21.34146341,26.17886179,
 26.60569106,18.06910569, 9.53252033, 6.54471545, 4.26829268, 1.84959350,
  1.96791444, 1.26203209, 0.96256684, 0.72727273, 0.57754011, 0.49197861,
  0.38502674, 0.34224599, 0.27807487, 0.29946524, 0.27807487, 0.25668449,
  0.19251337, 0.10695187, 0.04278075,-0.02139037,
 -0.02139037,-0.02139037,-0.02139037,-0.02139037,-0.02139037,-0.02139037,-0.02139037};

double interp(double x1, double y1, double x2, double y2, double x) {
    assert (x >= x1 && x <= x2);
    
    if (y1 > y2) 
        return (x2-x)/(x2-x1)*(y1-y2) + y2;
    else
        return (x-x1)/(x2-x1)*(y2-y1) + y1;
}//interp()

/*
** Linearly interpolate between point i and j, where
** xs[i] <= x <= xs[j]
** ASSUMES xs and ys is of len DENSITY_DATA_LEN
*/
double get_density_axis(double *xs, double *ys, double x) {
    if (x <= xs[0])
        return ( interp(0,0,xs[0],ys[0], x) );

    if (x >= xs[DENSITY_DATA_LEN - 1])
        return ( ys[DENSITY_DATA_LEN - 1]);
    
    int lo; // index in x of rightmost xs <= x
    for(lo = 0 ; xs[lo] <= x ; lo++);
    lo--;

    if (FEQUAL(xs[lo],x))        // no interpolation necessary
        return (ys[lo]);

    return interp(xs[lo], ys[lo], xs[lo+1], ys[lo+1], x);
}//get_density_axis()

/*
** Compute RGC density (# per mm^2) at (x,y) (coords in mm)
*/
double 
find_density(double x, double y) {
    double d1=0, d2=0, w=0;

    double r = sqrt(x*x + y*y);
    if (x < 0)  d1 = get_density_axis(temporal_x,  temporal_y,  r);
    if (x > 0)  d1 = get_density_axis(nasal_x, nasal_y, r);
    if (FEQUAL(x,0.0)) d1 = 0;

    if (y < 0)  d2 = get_density_axis(inferior_x, inferior_y, r);
    if (y > 0)  d2 = get_density_axis(superior_x, superior_y, r);
    if (FEQUAL(y,0.0)) d2 = 0;

    double theta = atan2(y, x) * 180.0 / M_PI;
    if (theta < 0)
        theta = 180 - theta;
    if (theta <= 90)
        w = theta/90;
    else if (theta <= 180)
        w = (180 - theta)/90;
    else if (theta <= 270)
        w = (theta - 180)/90;
    else
        w = (360 - theta)/90;

    return ((1-w) * d1 + w * d2) * 1000 ;
} //find_density()
